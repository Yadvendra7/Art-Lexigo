{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nconst {\n  fetch,\n  Request,\n  Headers\n} = require('./http/fetch');\nconst {\n  TimeoutError,\n  HTTPError\n} = require('./http/error');\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\nconst {\n  URL,\n  URLSearchParams\n} = require('iso-url');\nconst anySignal = require('any-signal');\nconst browserReableStreamToIt = require('browser-readablestream-to-it');\nconst {\n  isBrowser,\n  isWebWorker\n} = require('./env');\nconst all = require('it-all');\n\n/**\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n * @typedef {import('./types').ExtendedResponse} ExtendedResponse\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n  const start = Date.now();\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = next => {\n      /**\n       * @param {any} res\n       */\n      const fn = res => {\n        clearTimeout(timeoutID);\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n        next(res);\n      };\n      return fn;\n    };\n    promise.then(after(resolve), after(reject));\n  });\n};\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options);\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<ExtendedResponse>}\n   */\n  async fetch(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options);\n    // @ts-expect-error\n    const headers = new Headers(opts.headers);\n\n    // validate resource type\n    // @ts-expect-error\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    }\n    const url = new URL(resource.toString(), opts.base);\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts;\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams);\n      }\n    }\n    if (json) {\n      opts.body = JSON.stringify(opts.json);\n      headers.set('content-type', 'application/json');\n    }\n    const abortController = new AbortController();\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal]);\n    if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n      opts.body = new Blob(await all(browserReableStreamToIt(opts.body)));\n    }\n\n    /** @type {ExtendedResponse} */\n    // @ts-expect-error additional fields are assigned below\n    const response = await timeout(fetch(url.toString(), {\n      ...opts,\n      signal,\n      // @ts-expect-error non-browser fetch implementations may take extra options\n      timeout: undefined,\n      headers,\n      // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n      // https://github.com/whatwg/fetch/issues/1254\n      duplex: 'half'\n    }), opts.timeout, abortController);\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response);\n      }\n      throw new HTTPError(response);\n    }\n    response.iterator = async function* () {\n      yield* fromStream(response.body);\n    };\n    response.ndjson = async function* () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk);\n        } else {\n          yield chunk;\n        }\n      }\n    };\n    return response;\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  post(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'POST'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  get(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'GET'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  put(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'PUT'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  delete(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'DELETE'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  options(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'OPTIONS'\n    });\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n    buf = lines[lines.length - 1];\n  }\n  buf += decoder.decode();\n  buf = buf.trim();\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = source => {\n  if (isAsyncIterable(source)) {\n    return source;\n  }\n\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next: iter.next.bind(iter),\n          return(value) {\n            source.destroy();\n            if (typeof iter.return === 'function') {\n              return iter.return();\n            }\n            return Promise.resolve({\n              done: true,\n              value\n            });\n          }\n        };\n      }\n    };\n  }\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader();\n    return async function* () {\n      try {\n        while (true) {\n          // Read from the stream\n          const {\n            done,\n            value\n          } = await reader.read();\n          // Exit if we're done\n          if (done) return;\n          // Else yield the chunk\n          if (value) {\n            yield value;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    }();\n  }\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = value => {\n  return typeof value === 'object' && value !== null && typeof /** @type {any} */value[Symbol.asyncIterator] === 'function';\n};\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = value => {\n  return value && typeof /** @type {any} */value.getReader === 'function';\n};\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = value => Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = fromStream;\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\nmodule.exports = HTTP;","map":null,"metadata":{},"sourceType":"script"}