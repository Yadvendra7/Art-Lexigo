{"ast":null,"code":"'use strict';\n\nconst ip = require('./ip');\nconst protocols = require('./protocols-table');\nconst {\n  CID\n} = require('multiformats/cid');\nconst {\n  base32\n} = require('multiformats/bases/base32');\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\nconst Digest = require('multiformats/hashes/digest');\nconst varint = require('varint');\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\nmodule.exports = Convert;\n\n// converts (serializes) addresses\n/**\n * @param {string} proto\n * @param {string | Uint8Array} a\n */\nfunction Convert(proto, a) {\n  if (a instanceof Uint8Array) {\n    return Convert.toString(proto, a);\n  } else {\n    return Convert.toBytes(proto, a);\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n *\n * @param {number|string} proto\n * @param {Uint8Array} buf\n * @returns {string}\n */\nConvert.toString = function convertToString(proto, buf) {\n  const protocol = protocols(proto);\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41:\n      // ipv6\n      return bytes2ip(buf);\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132:\n      // sctp\n      return bytes2port(buf).toString();\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 777:\n      // memory\n      return bytes2str(buf);\n    case 421:\n      // ipfs\n      return bytes2mh(buf);\n    case 444:\n      // onion\n      return bytes2onion(buf);\n    case 445:\n      // onion3\n      return bytes2onion(buf);\n    default:\n      return uint8ArrayToString(buf, 'base16');\n    // no clue. convert to hex\n  }\n};\nConvert.toBytes = function convertToBytes( /** @type {string | number } */proto, /** @type {string} */str) {\n  const protocol = protocols(proto);\n  switch (protocol.code) {\n    case 4:\n      // ipv4\n      return ip2bytes(str);\n    case 41:\n      // ipv6\n      return ip2bytes(str);\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132:\n      // sctp\n      return port2bytes(parseInt(str, 10));\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 777:\n      // memory\n      return str2bytes(str);\n    case 421:\n      // ipfs\n      return mh2bytes(str);\n    case 444:\n      // onion\n      return onion2bytes(str);\n    case 445:\n      // onion3\n      return onion32bytes(str);\n    default:\n      return uint8ArrayFromString(str, 'base16');\n    // no clue. convert from hex\n  }\n};\n\n/**\n * @param {string} ipString\n */\nfunction ip2bytes(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n  return ip.toBytes(ipString);\n}\n\n/**\n * @param {Uint8Array} ipBuff\n */\nfunction bytes2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff);\n  if (!ipString || !ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n  return ipString;\n}\n\n/**\n * @param {number} port\n */\nfunction port2bytes(port) {\n  const buf = new ArrayBuffer(2);\n  const view = new DataView(buf);\n  view.setUint16(0, port);\n  return new Uint8Array(buf);\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction bytes2port(buf) {\n  const view = new DataView(buf.buffer);\n  return view.getUint16(buf.byteOffset);\n}\n\n/**\n * @param {string} str\n */\nfunction str2bytes(str) {\n  const buf = uint8ArrayFromString(str);\n  const size = Uint8Array.from(varint.encode(buf.length));\n  return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction bytes2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.decode.bytes);\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n  return uint8ArrayToString(buf);\n}\n\n/**\n * @param {string} hash - base58btc string\n */\nfunction mh2bytes(hash) {\n  let mh;\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n  } else {\n    mh = CID.parse(hash).multihash.bytes;\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length));\n  return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\n\n/**\n * Converts bytes to bas58btc string\n *\n * @param {Uint8Array} buf\n * @returns {string} base58btc string\n */\nfunction bytes2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.decode.bytes);\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n  return uint8ArrayToString(address, 'base58btc');\n}\n\n/**\n * @param {string} str\n */\nfunction onion2bytes(str) {\n  const addr = str.split(':');\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number');\n  }\n  if (addr[0].length !== 16) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.');\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0]);\n\n  // onion port number\n  const port = parseInt(addr[1], 10);\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\n/**\n * @param {string} str\n */\nfunction onion32bytes(str) {\n  const addr = str.split(':');\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number');\n  }\n  if (addr[0].length !== 56) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.');\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0]);\n\n  // onion port number\n  const port = parseInt(addr[1], 10);\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction bytes2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = uint8ArrayToString(addrBytes, 'base32');\n  const port = bytes2port(portBytes);\n  return addr + ':' + port;\n}","map":null,"metadata":{},"sourceType":"script"}