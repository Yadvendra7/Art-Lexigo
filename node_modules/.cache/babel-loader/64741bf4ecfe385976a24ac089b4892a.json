{"ast":null,"code":"'use strict';\n\nconst convert = require('./convert');\nconst protocols = require('./protocols-table');\nconst varint = require('varint');\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\n// export codec\nmodule.exports = {\n  stringToStringTuples,\n  stringTuplesToString,\n  tuplesToStringTuples,\n  stringTuplesToTuples,\n  bytesToTuples,\n  tuplesToBytes,\n  bytesToString,\n  stringToBytes,\n  fromString,\n  fromBytes,\n  validateBytes,\n  isValidBytes,\n  cleanPath,\n  ParseError,\n  protoFromTuple,\n  sizeForAddr\n};\n\n// string -> [[str name, str addr]... ]\n/**\n * @param {string} str\n */\nfunction stringToStringTuples(str) {\n  const tuples = [];\n  const parts = str.split('/').slice(1); // skip first empty elem\n  if (parts.length === 1 && parts[0] === '') {\n    return [];\n  }\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p];\n    const proto = protocols(part);\n    if (proto.size === 0) {\n      tuples.push([part]);\n      continue;\n    }\n    p++; // advance addr part\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str);\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path) {\n      tuples.push([part,\n      // TODO: should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      cleanPath(parts.slice(p).join('/'))]);\n      break;\n    }\n    tuples.push([part, parts[p]]);\n  }\n  return tuples;\n}\n\n// [[str name, str addr]... ] -> string\n/**\n * @param {[number, string?][]} tuples\n */\nfunction stringTuplesToString(tuples) {\n  /** @type {Array<string | undefined>} */\n  const parts = [];\n  tuples.map(tup => {\n    const proto = protoFromTuple(tup);\n    parts.push(proto.name);\n    if (tup.length > 1) {\n      parts.push(tup[1]);\n    }\n    return null;\n  });\n  return cleanPath(parts.join('/'));\n}\n\n// [[str name, str addr]... ] -> [[int code, Uint8Array]... ]\n/**\n * @param {Array<string[] | string >} tuples\n * @returns {[number , Uint8Array?][]}\n */\nfunction stringTuplesToTuples(tuples) {\n  return tuples.map(tup => {\n    if (!Array.isArray(tup)) {\n      tup = [tup];\n    }\n    const proto = protoFromTuple(tup);\n    if (tup.length > 1) {\n      return [proto.code, convert.toBytes(proto.code, tup[1])];\n    }\n    return [proto.code];\n  });\n}\n\n/**\n * Convert tuples to string tuples\n *\n * [[int code, Uint8Array]... ] -> [[int code, str addr]... ]\n *\n * @param {Array<[number, Uint8Array?]>} tuples\n * @returns {Array<[number, string?]>}\n */\n\nfunction tuplesToStringTuples(tuples) {\n  return tuples.map(tup => {\n    const proto = protoFromTuple(tup);\n    if (tup[1]) {\n      return [proto.code, convert.toString(proto.code, tup[1])];\n    }\n    return [proto.code];\n  });\n}\n\n// [[int code, Uint8Array ]... ] -> Uint8Array\n/**\n * @param {[number, Uint8Array?][]} tuples\n */\nfunction tuplesToBytes(tuples) {\n  return fromBytes(uint8ArrayConcat(tuples.map(( /** @type {any[]} */tup) => {\n    const proto = protoFromTuple(tup);\n    let buf = Uint8Array.from(varint.encode(proto.code));\n    if (tup.length > 1) {\n      buf = uint8ArrayConcat([buf, tup[1]]); // add address buffer\n    }\n    return buf;\n  })));\n}\n\n/**\n * @param {import(\"./types\").Protocol} p\n * @param {Uint8Array | number[]} addr\n */\nfunction sizeForAddr(p, addr) {\n  if (p.size > 0) {\n    return p.size / 8;\n  } else if (p.size === 0) {\n    return 0;\n  } else {\n    const size = varint.decode(addr);\n    return size + varint.decode.bytes;\n  }\n}\n\n/**\n *\n * @param {Uint8Array} buf\n * @returns {Array<[number, Uint8Array?]>}\n */\nfunction bytesToTuples(buf) {\n  /** @type {Array<[number, Uint8Array?]>} */\n  const tuples = [];\n  let i = 0;\n  while (i < buf.length) {\n    const code = varint.decode(buf, i);\n    const n = varint.decode.bytes;\n    const p = protocols(code);\n    const size = sizeForAddr(p, buf.slice(i + n));\n    if (size === 0) {\n      tuples.push([code]);\n      i += n;\n      continue;\n    }\n    const addr = buf.slice(i + n, i + n + size);\n    i += size + n;\n    if (i > buf.length) {\n      // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'));\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr]);\n  }\n  return tuples;\n}\n\n// Uint8Array -> String\n/**\n * @param {Uint8Array} buf\n */\nfunction bytesToString(buf) {\n  const a = bytesToTuples(buf);\n  const b = tuplesToStringTuples(a);\n  return stringTuplesToString(b);\n}\n\n// String -> Uint8Array\n/**\n * @param {string} str\n */\nfunction stringToBytes(str) {\n  str = cleanPath(str);\n  const a = stringToStringTuples(str);\n  const b = stringTuplesToTuples(a);\n  return tuplesToBytes(b);\n}\n\n// String -> Uint8Array\n/**\n * @param {string} str\n */\nfunction fromString(str) {\n  return stringToBytes(str);\n}\n\n// Uint8Array -> Uint8Array\n/**\n * @param {Uint8Array} buf\n */\nfunction fromBytes(buf) {\n  const err = validateBytes(buf);\n  if (err) throw err;\n  return Uint8Array.from(buf); // copy\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction validateBytes(buf) {\n  try {\n    bytesToTuples(buf); // try to parse. will throw if breaks\n  } catch (err) {\n    return err;\n  }\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction isValidBytes(buf) {\n  return validateBytes(buf) === undefined;\n}\n\n/**\n * @param {string} str\n */\nfunction cleanPath(str) {\n  return '/' + str.trim().split('/').filter(( /** @type {any} */a) => a).join('/');\n}\n\n/**\n * @param {string} str\n */\nfunction ParseError(str) {\n  return new Error('Error parsing address: ' + str);\n}\n\n/**\n * @param {any[]} tup\n */\nfunction protoFromTuple(tup) {\n  const proto = protocols(tup[0]);\n  return proto;\n}","map":null,"metadata":{},"sourceType":"script"}